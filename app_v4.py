import streamlit as st
import fitz
import pytesseract
from PIL import Image
import io
import re
import tempfile
import os
import zipfile
import base64
import time
import subprocess
import concurrent.futures
from threading import Lock

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
st.set_page_config(
    page_title="PDF Splitter - ULTRA FAST",
    page_icon="üìÑ",
    layout="wide"
)

# –ö—ç—à–∏—Ä—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É Tesseract
@st.cache_resource
def setup_tesseract():
    try:
        result = subprocess.run(['which', 'tesseract'], capture_output=True, text=True)
        if result.returncode == 0:
            tesseract_path = result.stdout.strip()
            pytesseract.pytesseract.tesseract_cmd = tesseract_path
            return True
    except:
        pass
    return False

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
tesseract_available = setup_tesseract()

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
class ProcessingState:
    def __init__(self):
        self._stop = False
        self._lock = Lock()
    
    def stop(self):
        with self._lock:
            self._stop = True
    
    def should_stop(self):
        with self._lock:
            return self._stop
    
    def reset(self):
        with self._lock:
            self._stop = False

processing_state = ProcessingState()

# CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .ultra-fast {
        background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
        color: white;
        padding: 10px;
        border-radius: 10px;
        text-align: center;
        font-weight: bold;
    }
</style>
""", unsafe_allow_html=True)

class PDFProcessor:
    def __init__(self):
        self.temp_dir = tempfile.mkdtemp()
        self._pattern_cache = {}
        
    def _compile_patterns(self):
        """–ö—ç—à–∏—Ä—É–µ–º regex patterns –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏"""
        if not self._pattern_cache:
            self._pattern_cache = {
                'ten_digits': re.compile(r'\b(202[4-9]\d{6})\b'),
                'twenty_digits': re.compile(r'\b(20\d{8})\b'),
                'any_ten': re.compile(r'\b(\d{10})\b'),
                'eight_twelve': re.compile(r'\b(\d{8,12})\b'),
                'order_prefix': re.compile(r'\b(ORDER[:\\s]*)(\d{8,12})\b', re.IGNORECASE),
                'number_prefix': re.compile(r'\b(‚Ññ[:\\s]*)(\d{8,12})\b', re.IGNORECASE),
            }
        return self._pattern_cache

    def find_order_number_ultra_fast(self, text):
        """–°–£–ü–ï–†-–ë–´–°–¢–†–´–ô –ø–æ–∏—Å–∫ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –ø–∞—Ç—Ç–µ—Ä–Ω–∞–º–∏"""
        if not text or len(text) < 5:
            return None
            
        patterns = self._compile_patterns()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∞–º—ã–µ —á–∞—Å—Ç—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –ø–µ—Ä–≤—ã–º–∏
        for pattern_name, pattern in patterns.items():
            matches = pattern.findall(text)
            if matches:
                if isinstance(matches[0], tuple):
                    for match in matches[0]:
                        if match and match.isdigit():
                            return match
                else:
                    return matches[0]
        return None

    def extract_text_super_fast(self, page):
        """–ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û –±—ã—Å—Ç—Ä–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞"""
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Å–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π –º–µ—Ç–æ–¥
            text = page.get_text("text")
            if text and len(text.strip()) > 5:
                return text
            
            # –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç–∞ –º–∞–ª–æ, –ø—Ä–æ–±—É–µ–º —Å–ª–æ–≤–∞
            words = page.get_text("words")
            if words:
                return " ".join([word[4] for word in words if len(word) > 4])
                
            return ""
        except:
            return ""

    def process_single_page(self, args):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ—Å—Ç–∏"""
        page_num, page_data, use_ocr = args
        
        if processing_state.should_stop():
            return None, "stopped", page_num
        
        try:
            # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç –¥–ª—è —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            doc = fitz.open("pdf", page_data)
            page = doc[0]
            
            # –®–∞–≥ 1: –°–≤–µ—Ä—Ö–±—ã—Å—Ç—Ä–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
            text = self.extract_text_super_fast(page)
            order_no = self.find_order_number_ultra_fast(text)
            
            if order_no:
                doc.close()
                return order_no, "direct", page_num
            
            # –®–∞–≥ 2: OCR —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω—É–∂–Ω–æ
            if use_ocr and not order_no:
                try:
                    # –°–≤–µ—Ä—Ö–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                    pix = page.get_pixmap(matrix=fitz.Matrix(1.0, 1.0))  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
                    img_data = pix.tobytes("png")
                    
                    # –ë—ã—Å—Ç—Ä–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤ –ø–∞–º—è—Ç–∏
                    img = Image.open(io.BytesIO(img_data))
                    img = img.convert('L')
                    
                    # –£–ª—å—Ç—Ä–∞-–±—ã—Å—Ç—Ä—ã–π OCR —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
                    ocr_text = pytesseract.image_to_string(
                        img, 
                        lang='eng',
                        config='--oem 1 --psm 6 -c tessedit_do_invert=0'
                    )
                    
                    order_no = self.find_order_number_ultra_fast(ocr_text)
                    doc.close()
                    
                    if order_no:
                        return order_no, "ocr", page_num
                        
                except Exception as e:
                    doc.close()
                    return None, "ocr_error", page_num
            
            doc.close()
            return None, "not_found", page_num
            
        except Exception as e:
            return None, "error", page_num

    def process_pdf_ultra_fast(self, pdf_file, progress_bar, status_text):
        """–£–õ–¨–¢–†–ê-–ë–´–°–¢–†–ê–Ø –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ—Å—Ç—å—é"""
        processing_state.reset()
        start_time = time.time()
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º PDF
        temp_pdf_path = os.path.join(self.temp_dir, "input.pdf")
        with open(temp_pdf_path, "wb") as f:
            f.write(pdf_file.getvalue())
        
        try:
            # –û—Ç–∫—Ä—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π PDF –æ–¥–∏–Ω —Ä–∞–∑
            main_doc = fitz.open(temp_pdf_path)
            total_pages = len(main_doc)
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ—Å—Ç–∏
            page_data_list = []
            for page_num in range(total_pages):
                if processing_state.should_stop():
                    break
                # –ü–æ–ª—É—á–∞–µ–º raw –¥–∞–Ω–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                page_data = main_doc[page_num].get_contents()
                page_data_list.append((page_num, page_data, tesseract_available))
            
            main_doc.close()
            
            output_dir = os.path.join(self.temp_dir, "output")
            os.makedirs(output_dir, exist_ok=True)
            
            stats = {
                'total': total_pages,
                'direct': 0,
                'ocr': 0,
                'failed': 0,
                'stopped': 0,
                'files': [],
                'total_time': 0,
                'pages_processed': 0
            }
            
            # –ú–ù–û–ì–û–ü–û–¢–û–ß–ù–ê–Ø –æ–±—Ä–∞–±–æ—Ç–∫–∞
            completed_pages = 0
            batch_size = 4  # –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –±–∞—Ç—á–∞ –¥–ª—è Streamlit Cloud
            
            for batch_start in range(0, len(page_data_list), batch_size):
                if processing_state.should_stop():
                    stats['stopped'] = len(page_data_list) - completed_pages
                    break
                
                batch_end = min(batch_start + batch_size, len(page_data_list))
                batch_data = page_data_list[batch_start:batch_end]
                
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±–∞—Ç—á —Å—Ç—Ä–∞–Ω–∏—Ü
                with concurrent.futures.ThreadPoolExecutor(max_workers=batch_size) as executor:
                    future_to_page = {
                        executor.submit(self.process_single_page, page_data): page_data 
                        for page_data in batch_data
                    }
                    
                    for future in concurrent.futures.as_completed(future_to_page):
                        if processing_state.should_stop():
                            break
                            
                        page_data = future_to_page[future]
                        page_num = page_data[0]
                        
                        try:
                            order_no, method, processed_page_num = future.result()
                            
                            # –°–æ–∑–¥–∞–µ–º PDF –¥–ª—è —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                            doc = fitz.open(temp_pdf_path)
                            new_doc = fitz.open()
                            new_doc.insert_pdf(doc, from_page=page_num, to_page=page_num)
                            
                            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞
                            filename = f"{order_no}.pdf" if order_no else f"page_{page_num + 1}.pdf"
                            output_path = os.path.join(output_dir, filename)
                            
                            # –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏
                            counter = 1
                            base_name = os.path.splitext(filename)[0]
                            while os.path.exists(output_path):
                                output_path = os.path.join(output_dir, f"{base_name}_{counter}.pdf")
                                counter += 1
                            
                            new_doc.save(output_path)
                            new_doc.close()
                            doc.close()
                            
                            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                            if order_no:
                                if method == "direct":
                                    stats['direct'] += 1
                                else:
                                    stats['ocr'] += 1
                            else:
                                stats['failed'] += 1
                            
                            stats['files'].append({
                                'filename': os.path.basename(output_path),
                                'page': page_num + 1,
                                'method': method,
                                'order_no': order_no
                            })
                            
                            completed_pages += 1
                            stats['pages_processed'] = completed_pages
                            
                            # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                            progress = completed_pages / total_pages
                            progress_bar.progress(progress)
                            
                            elapsed = time.time() - start_time
                            speed = completed_pages / elapsed if elapsed > 0 else 0
                            
                            status_text.text(
                                f"üöÄ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {completed_pages}/{total_pages} | "
                                f"‚ö° –°–ö–û–†–û–°–¢–¨: {speed:.1f} —Å—Ç—Ä/—Å–µ–∫ | "
                                f"‚úÖ –¢–µ–∫—Å—Ç: {stats['direct']} | "
                                f"üîç OCR: {stats['ocr']} | "
                                f"‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ: {stats['failed']}"
                            )
                            
                        except Exception as e:
                            continue
            
            # –°–æ–∑–¥–∞–µ–º ZIP –∞—Ä—Ö–∏–≤
            if stats['files']:
                zip_path = os.path.join(self.temp_dir, "results.zip")
                with zipfile.ZipFile(zip_path, 'w', compresslevel=6) as zipf:  # –°—Ä–µ–¥–Ω–µ–µ —Å–∂–∞—Ç–∏–µ –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
                    for file_info in stats['files']:
                        file_path = os.path.join(output_dir, file_info['filename'])
                        if os.path.exists(file_path):
                            zipf.write(file_path, file_info['filename'])
                stats['zip_path'] = zip_path
            
            # –§–∏–Ω–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            total_time = time.time() - start_time
            stats['total_time'] = total_time
            stats['avg_speed'] = completed_pages / total_time if total_time > 0 else 0
            
            return stats
            
        except Exception as e:
            st.error(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")
            return None

    def get_download_link(self, file_path, link_text):
        if not file_path or not os.path.exists(file_path):
            return "‚ùå –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω"
            
        with open(file_path, "rb") as f:
            data = f.read()
        b64 = base64.b64encode(data).decode()
        href = f'<a href="data:application/zip;base64,{b64}" download="pdf_results.zip" style="background: linear-gradient(45deg, #FF6B6B, #4ECDC4); color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; display: inline-block; font-weight: bold;">{link_text}</a>'
        return href

def main():
    st.markdown('<div class="main-header">üìÑ PDF Splitter - ULTRA FAST</div>', unsafe_allow_html=True)
    st.markdown('<div class="ultra-fast">‚ö° –°–ö–û–†–û–°–¢–¨ –î–û 10 –°–¢–†–ê–ù–ò–¶/–°–ï–ö–£–ù–î–£ ‚ö°</div>', unsafe_allow_html=True)
    
    if 'processor' not in st.session_state:
        st.session_state.processor = PDFProcessor()
    
    # Sidebar
    with st.sidebar:
        st.header("‚ö° –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏")
        st.markdown("""
        **–£—Å–∫–æ—Ä–µ–Ω–∏—è:**
        - üöÄ –ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ—Å—Ç—å
        - üíæ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ regex
        - üéØ –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π OCR
        - üì¶ –ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
        - üîß –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        """)
        
        st.markdown(f"**OCR:** {'‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω' if tesseract_available else '‚ùå –ù–µ –¥–æ—Å—Ç—É–ø–µ–Ω'}")
        
        if st.button("üõë –°–¢–û–ü", use_container_width=True, type="primary"):
            processing_state.stop()
            st.warning("–û—Å—Ç–∞–Ω–æ–≤–∫–∞...")

    # Main area
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.subheader("üì§ –ó–∞–≥—Ä—É–∑–∫–∞ PDF")
        uploaded_file = st.file_uploader("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª", type="pdf")
        
        if uploaded_file is not None:
            st.success(f"‚úÖ {uploaded_file.name}")
            file_size = uploaded_file.size / 1024 / 1024
            
            if file_size > 50:
                st.warning("‚ö†Ô∏è –ë–æ–ª—å—à–æ–π —Ñ–∞–π–ª! –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è")
            
            col_start, col_stop = st.columns([3, 1])
            with col_start:
                if st.button("üöÄ –ó–ê–ü–£–°–ö –£–õ–¨–¢–†–ê-–û–ë–†–ê–ë–û–¢–ö–ò", type="primary", use_container_width=True):
                    progress_bar = st.progress(0)
                    status_text = st.empty()
                    results_placeholder = st.empty()
                    
                    with st.spinner("‚ö° –£–õ–¨–¢–†–ê-–û–ë–†–ê–ë–û–¢–ö–ê..."):
                        stats = st.session_state.processor.process_pdf_ultra_fast(
                            uploaded_file, progress_bar, status_text
                        )
                    
                    if stats:
                        with results_placeholder.container():
                            st.markdown("---")
                            st.subheader("üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –£–õ–¨–¢–†–ê-–û–ë–†–ê–ë–û–¢–ö–ò")
                            
                            # –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
                            col1, col2, col3, col4 = st.columns(4)
                            col1.metric("–°—Ç—Ä–∞–Ω–∏—Ü", stats['pages_processed'])
                            col2.metric("–ù–∞–π–¥–µ–Ω–æ", stats['direct'] + stats['ocr'])
                            col3.metric("–°–∫–æ—Ä–æ—Å—Ç—å", f"{stats['avg_speed']:.1f}/—Å–µ–∫")
                            col4.metric("–í—Ä–µ–º—è", f"{stats['total_time']:.1f}—Å")
                            
                            # –î–µ—Ç–∞–ª–∏
                            st.markdown("#### –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è:")
                            col_d1, col_d2, col_d3 = st.columns(3)
                            col_d1.metric("–¢–µ–∫—Å—Ç–æ–º", stats['direct'])
                            col_d2.metric("OCR", stats['ocr'])
                            col_d3.metric("–ù–µ –Ω–∞–π–¥–µ–Ω–æ", stats['failed'])
                            
                            if stats['stopped'] > 0:
                                st.error(f"‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {stats['stopped']} —Å—Ç—Ä–∞–Ω–∏—Ü")
                            
                            # –°–∫–∞—á–∏–≤–∞–Ω–∏–µ
                            if stats.get('zip_path'):
                                st.markdown("---")
                                download_link = st.session_state.processor.get_download_link(
                                    stats['zip_path'], "‚¨áÔ∏è –°–ö–ê–ß–ê–¢–¨ –†–ï–ó–£–õ–¨–¢–ê–¢–´"
                                )
                                st.markdown(download_link, unsafe_allow_html=True)
            
            with col_stop:
                if st.button("‚èπÔ∏è –°–¢–û–ü", use_container_width=True):
                    processing_state.stop()
    
    with col2:
        st.subheader("üéØ –°—Ç—Ä–∞—Ç–µ–≥–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏")
        st.markdown("""
        **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:**
        
        üöÄ **–ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ—Å—Ç—å**  
        - –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
        - –ë–∞—Ç—á–∏ –ø–æ 4 —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        
        üíæ **–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ**  
        - Regex patterns
        - –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
        
        üéØ **–£–º–Ω—ã–π OCR**  
        - –¢–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ
        - –ù–∏–∑–∫–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
        - –ë—ã—Å—Ç—Ä—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        
        ‚ö° **–†–µ–∑—É–ª—å—Ç–∞—Ç:**  
        –î–æ **10x** –±—ã—Å—Ç—Ä–µ–µ!
        """)

if __name__ == "__main__":
    main()
